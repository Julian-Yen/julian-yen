{"version":3,"sources":["soundmap.js"],"names":["AudioContext","window","webkitAudioContext","audioContext","bgm","document","querySelector","audioElement","track","createMediaElementSource","connect","destination","addEventListener","state","resume","dataset","playing","play","pause","classList","toggle","gainNode","createGain","stage","Konva","Stage","container","width","innerWidth","height","innerHeight","layer","Layer","w","analyserNode","createAnalyser","waveformCanvas","wfCanvasContext","getContext","analyserNode2","waveformCanvas2","wfCanvasContext2","random","min","max","num","Math","floor","id","id2","continueAnimating","continueAnimating2","draw","requestAnimationFrame","minDecibels","fftSize","bufferLength","frequencyBinCount","WIDTH","waveformArray","Uint8Array","getByteTimeDomainData","clearRect","lineWidth","strokeStyle","beginPath","sliceWidth","x","i","v","y","moveTo","lineTo","stroke","draw2","soundFolder","sources","loopfolder","time","filename","sounds","console","log","fetch","then","data","arrayBuffer","decodeAudioData","decodeAudio","length","playSound","playSound2","HEIGHT","stopAll","stop","gain","linearRampToValueAtTime","currentTime","loop","setTimeout","playback","index","createBufferSource","buffer","start","cancelAnimationFrame","mozCancelAnimationFrame","btn","a","b","circle","Circle","radius","fill","opacity","draggable","globalCompositeOperation","on","add"],"mappings":"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","file":"soundmap.ccf917bc.js","sourceRoot":"../src","sourcesContent":["const AudioContext = window.AudioContext || window.webkitAudioContext;\r\nconst audioContext = new AudioContext();\r\n\r\nconst bgm = document.querySelector('.bgm');\r\nconst audioElement = document.querySelector('audio');\r\nconst track = audioContext.createMediaElementSource(audioElement);\r\ntrack.connect(audioContext.destination);\r\n// if track ends\r\n\r\nbgm.addEventListener('click', function () {\r\n  // check if context is in suspended state (autoplay policy)\r\n  if (audioContext.state === 'suspended') {\r\n    audioContext.resume();\r\n  }\r\n\r\n  if (this.dataset.playing === 'false') {\r\n    audioElement.play();\r\n    this.dataset.playing = 'true';\r\n\r\n    // if track is playing pause it\r\n  } else if (this.dataset.playing === 'true') {\r\n    audioElement.pause();\r\n    this.dataset.playing = 'false';\r\n  }\r\n  bgm.classList.toggle('pause');\r\n});\r\n\r\naudioElement.addEventListener(\r\n  'ended',\r\n  () => {\r\n    bgm.dataset.playing = 'false';\r\n    bgm.classList.toggle('pause');\r\n  },\r\n  false\r\n);\r\n\r\n//whether I should only add one gain node?\r\nvar gainNode = audioContext.createGain();\r\n\r\n// connect the AudioBufferSourceNode to the gainNode\r\n// and the gainNode to the destination\r\n//gainNode.gain.setValueAtTime(1, audioContext.currentTime);\r\n\r\n//linearRampMinus.onclick = function() {\r\n//gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2);\r\n//}\r\n\r\n//create an environment for the file to be in the buffer\r\n// first we need to create a stage\r\nvar stage = new Konva.Stage({\r\n  container: 'box', // id of container <div>\r\n  width: window.innerWidth,\r\n  height: window.innerHeight + 1000,\r\n});\r\n// then create layer\r\nvar layer = new Konva.Layer();\r\nconst w = window.innerWidth;\r\n\r\n//testing the fourier shit\r\nconst analyserNode = audioContext.createAnalyser();\r\nconst waveformCanvas = document.querySelector('#waveform');\r\nconst wfCanvasContext = waveformCanvas.getContext('2d');\r\nwaveformCanvas.width = w;\r\n\r\nconst analyserNode2 = audioContext.createAnalyser();\r\nconst waveformCanvas2 = document.querySelector('#waveform2');\r\nconst wfCanvasContext2 = waveformCanvas2.getContext('2d');\r\nwaveformCanvas2.width = w;\r\n\r\n//define functions\r\nfunction random(min, max) {\r\n  const num = Math.floor(Math.random() * (max - min + 1)) + min;\r\n  return num;\r\n}\r\n\r\nvar id = null;\r\nvar id2 = null;\r\nvar continueAnimating = true;\r\nvar continueAnimating2 = true;\r\n//fourier shit\r\nfunction draw() {\r\n  if (continueAnimating) {\r\n    id = requestAnimationFrame(draw);\r\n  }\r\n\r\n  // only animate while playing (reduces CPU load)\r\n\r\n  // connect the analyser to the destination\r\n  //fourier shit\r\n  analyserNode.minDecibels = -150;\r\n  analyserNode.fftSize = 1024;\r\n  let bufferLength = analyserNode.frequencyBinCount;\r\n  const WIDTH = w;\r\n  const HEIGHT = 200;\r\n  let waveformArray = new Uint8Array(bufferLength);\r\n\r\n  // time domain visualization\r\n  analyserNode.getByteTimeDomainData(waveformArray);\r\n  wfCanvasContext.clearRect(0, 0, WIDTH, HEIGHT);\r\n  wfCanvasContext.lineWidth = 2;\r\n  wfCanvasContext.strokeStyle = '#fff';\r\n  wfCanvasContext.beginPath();\r\n  const sliceWidth = (WIDTH * 1.0) / bufferLength;\r\n  let x = 0;\r\n  for (let i = 0; i < bufferLength; i++) {\r\n    const v = waveformArray[i] / 128.0;\r\n    const y = (v * HEIGHT) / 2;\r\n    if (i === 0) {\r\n      wfCanvasContext.moveTo(x, y);\r\n    } else {\r\n      wfCanvasContext.lineTo(x, y);\r\n    }\r\n    x += sliceWidth;\r\n  }\r\n  wfCanvasContext.lineTo(waveformCanvas.width, waveformCanvas.height / 2);\r\n  wfCanvasContext.stroke();\r\n}\r\n\r\nfunction draw2() {\r\n  if (continueAnimating2) {\r\n    id2 = requestAnimationFrame(draw2);\r\n  }\r\n\r\n  // only animate while playing (reduces CPU load)\r\n\r\n  // connect the analyser to the destination\r\n  //fourier shit\r\n  analyserNode2.minDecibels = -150;\r\n  analyserNode2.fftSize = 1024;\r\n  let bufferLength = analyserNode.frequencyBinCount;\r\n  const WIDTH = w;\r\n  const HEIGHT = 200;\r\n  let waveformArray = new Uint8Array(bufferLength);\r\n\r\n  // time domain visualization\r\n  analyserNode2.getByteTimeDomainData(waveformArray);\r\n  wfCanvasContext2.clearRect(0, 0, WIDTH, HEIGHT);\r\n  wfCanvasContext2.lineWidth = 2;\r\n  wfCanvasContext2.strokeStyle = '#fff';\r\n  wfCanvasContext2.beginPath();\r\n  const sliceWidth = (WIDTH * 1.0) / bufferLength;\r\n  let x = 0;\r\n  for (let i = 0; i < bufferLength; i++) {\r\n    const v = waveformArray[i] / 128.0;\r\n    const y = (v * HEIGHT) / 2;\r\n    if (i === 0) {\r\n      wfCanvasContext2.moveTo(x, y);\r\n    } else {\r\n      wfCanvasContext2.lineTo(x, y);\r\n    }\r\n    x += sliceWidth;\r\n  }\r\n  wfCanvasContext2.lineTo(waveformCanvas2.width, waveformCanvas2.height / 2);\r\n  wfCanvasContext2.stroke();\r\n}\r\n\r\n//loading the sounds into a folder\r\nvar soundFolder = [];\r\nvar sources = [];\r\nvar loopfolder = [];\r\nvar floor = [];\r\nvar time = [];\r\n\r\nfor (let i = 0; i < sounds.length; i++) {\r\n  var filename = sounds[i]['path'];\r\n  floor[i] = sounds[i]['level'];\r\n  time[i] = sounds[i]['time'];\r\n  console.log(filename);\r\n  fetch(filename)\r\n    .then((data) => data.arrayBuffer())\r\n    .then((arrayBuffer) => audioContext.decodeAudioData(arrayBuffer))\r\n    .then((decodeAudio) => {\r\n      soundFolder[i] = decodeAudio;\r\n    });\r\n  //soundFolder[i] = audio;\r\n}\r\nconst WIDTH = w;\r\nconst HEIGHT = 200;\r\nwindow.cancelAnimationFrame || window.mozCancelAnimationFrame;\r\n\r\nlet playSound;\r\nlet playSound2;\r\n\r\nfunction stopAll() {\r\n  for (let i = 0; i < sources.length; i++) {\r\n    //id = requestAnimationFrame(draw);\r\n    //cancelAnimationFrame(id);\r\n    // To turn off animation\r\n    if (sources[i]) sources[i].stop();\r\n  }\r\n  gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);\r\n\r\n  playSound2.loop = false;\r\n  continueAnimating = false;\r\n  //wfCanvasContext.clearRect(0, 0, WIDTH, HEIGHT);\r\n  setTimeout(function () {\r\n    wfCanvasContext.clearRect(0, 0, WIDTH, HEIGHT);\r\n  }, 50);\r\n  setTimeout(function () {\r\n    playSound2.stop();\r\n    playSound.stop();\r\n  }, 1000);\r\n}\r\n\r\n/*function scheduler(audioStart, index) {\r\n  audio = context.createBufferSource();\r\n  sources[index] = audio;\r\n  audio.buffer = audioSamples[index]; //array with all the loaded audio\r\n  audio.connect(context.destination);\r\n  audio.start(audioStart + audio.buffer.duration * index);\r\n}*/\r\n//control the play and pause\r\n//for changing sound, can use (e){e.target.fill or something, [this] also works I guess?}\r\n\r\nfunction playback(index) {\r\n  playSound = audioContext.createBufferSource();\r\n  sources[index] = playSound;\r\n  playSound.buffer = soundFolder[index];\r\n  //playSound.buffer = audio;\r\n  continueAnimating2 = true;\r\n  playSound.connect(gainNode);\r\n  gainNode.connect(analyserNode2);\r\n  analyserNode2.connect(audioContext.destination);\r\n  gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 1);\r\n  //analyserNode.connect(audioContext.destination);\r\n  playSound.start(audioContext.currentTime);\r\n  layer.draw();\r\n  draw2();\r\n  //console.log(playSound.isPlaying);\r\n}\r\n\r\nfunction loop(index) {\r\n  playSound2 = audioContext.createBufferSource();\r\n  loopfolder[index] = playSound2;\r\n  playSound2.buffer = soundFolder[index];\r\n  playSound2.connect(gainNode);\r\n  gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 1);\r\n  gainNode.connect(analyserNode);\r\n  analyserNode.connect(audioContext.destination);\r\n  playSound2.start(0);\r\n  playSound2.loop = true;\r\n  continueAnimating = true;\r\n  draw();\r\n}\r\n\r\nfunction pause() {\r\n  playSound.stop();\r\n  continueAnimating2 = false;\r\n  setTimeout(function () {\r\n    wfCanvasContext2.clearRect(0, 0, WIDTH, HEIGHT);\r\n  }, 50);\r\n}\r\n\r\nconst btn = document.querySelector('#clear');\r\nbtn.addEventListener('click', stopAll);\r\n// draw the image\r\n//function load() {\r\nfor (let i = 0; i < 26; i++) {\r\n  // create our shape\r\n  let a = time[i];\r\n  let b = floor[i];\r\n  console.log(a);\r\n  console.log(b);\r\n  var circle = new Konva.Circle({\r\n    x: a * 150 - 1450,\r\n    y: b * 400 - 300 + random(0, 500),\r\n    radius: random(30, 40),\r\n    fill: 'white',\r\n    opacity: 1,\r\n    draggable: true,\r\n    globalCompositeOperation: 'saturation',\r\n  });\r\n\r\n  //call function vs call function + parameter\r\n  circle.on('mouseover', function () {\r\n    playback(i);\r\n    var fill = 'black';\r\n    this.fill(fill);\r\n    layer.draw();\r\n  });\r\n  circle.on('mouseout', function () {\r\n    pause();\r\n    var fill = 'Azure';\r\n    this.fill(fill);\r\n    layer.draw();\r\n  });\r\n  circle.on('click', function () {\r\n    loop(i);\r\n  });\r\n\r\n  // add the shape to the layer\r\n  layer.add(circle);\r\n  layer.draw();\r\n  stage.add(layer);\r\n\r\n  //circle.to({ opacity: 1 });\r\n}\r\n\r\n//}\r\n\r\n//const btn2 = document.querySelector('#load');\r\n//btn2.addEventListener('click', load);\r\n\r\n/*\r\nto-do:\r\n\r\nFilter the location from soundjs and forming it into different arrays\r\n\r\nClicking on the region:\r\n\r\nclear the stage\r\n\r\ndecode the sounds and put it into the array\r\n\r\nload the circles \r\n*/\r\n"]}